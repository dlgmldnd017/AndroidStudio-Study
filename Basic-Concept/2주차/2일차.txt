※인텐트

- 인텐트에 클래스 객체나 컴포넌트 이름을 지정하여 호출할 대상을 확실히 알 수 있는 경우에는 '명시적 인텐트' 라고 부른다.

- 액션과 데이터를 지정하긴 했지만 호출할 대상이 달라질 수 있는 경우에 '암시적 인텐트' 라고 부른다.

	+ 암시적 인텐트는 액션과 데이터로 구성되지만 그외에도 여러 가지 속성을 가지고 있다. 대표적으로는 다음과 같다.
	
	+ 범주, 타입, 컴포넌트, 부가데이터가 된다.

	+ 범주는 액션이 실행되는 데 필요한 추가적인 정보를 제공한다.
	
	+ 타입은 인텐트에 들어가는 데이터의 MINE 타입을 명시적으로 지정한다.

	+ 컴포넌트는 인텐트에 사용될 컴포넌트 클래스 이름을 명시적으로 지정한다.

	+ 부가 데이터는 추가적인 정보를 넣을 수 있도록 번들 객체를 담고 있다.

- 컴포넌트 이름을 지정할 때, 패키지 이름까지 넣어서 사용한

- startActivityForResult() (A 엑티비티) --> setResult() (B 엑티비티) --> onActivityResult() (A엑티비티) 

	+ Activity.RESULT_OK는 성공을 의미한다.
	
	+ Activity.RESULT_CANCELED는 실패 또는 비정상 종료를 의미한다.

- 시스템이 요청하는 인텐트의 정보를 받아 처리한 에플리케이션 구성 요소를 찾기 위해 필요한 정보가 바로 '인텐트 필터' 이다.

	+ 인텐트가 가지는 액션 정보를 동일하게 가질 수 있는데 이 인텐트 필터에 지정한 인테트만 전달 받겠다는 의미이다.
	
	+ 시스템은 전달 받은 인텐트를 해석한 후, 단말에 설치된 앱들 중에서 인텐트와 동일한 액션 정보를 가진 인텐트 필터가 있는 앱들에게 
	인텐트를 전달한다.


※액티비티를 위한 플래그와 부가 데이터

- 액티비티로 만들어진 화면이 한 번 메모리에 만들어졌는데, 계속 startActivity() 또는 startActivityForResult() 메소드가 반복적으로 호출되면
동일한 엑티비티가 여러개 만들어집니다. 이 때는 '플래그'를 사용해 액티비티가 동작하는 방식을 조정할 수 있다.

- 만약에 동일한 액티비티를 여러 번 실행한다면, 동일한 액티비티가 스택에 쌓이고 동시에 데이터를 여러 번 접근하거나 리소스를 여러 번 사용하는
문제가 발생할 수 있다. 이를 해결해주는 플래그가 있는데 대표적인 것은 다음과 같다.

	+ FLAG_ACTIVITY_SINGLE_TOP 는 액티비티를 생성할 때 이미 생성된 액티비티가 있으면 그 액티비티를 그대로 사용하는 플래그이다.
	
	그러면 화면에 보이는 액티비티가 새로 만들어지지 않고 기존에 있는 것이 보인다면 시스템에서 전달하는 인텐트 객체를 어떻게 전달
	받을까? onCreate() 메소드 안에 getIntent()를 사용하면 되지만 이것은 다시 띄워진 액티비티를 처리하지 못한다. 그러면 우리는 onNewIntent()
	메소드를 재정의하면 인텐트 객체만 전달 받을 수 있다.

	+ FLAG_ACTIVITY_NO_HISTORY 는 처음 이후에 실행된 액티비티는 액티비티 스택에 추가되지 않는다. 사용자에게 한 번 알림 화면을 보여
	주고 싶을 때 유용하게 사용한다.
	
	+ FLAG_ACTIVITY_CLEAR_TOP 는 액티비티 위에 있는 다른 액티비티를 모두 종료하게 된다. 이 플래그는 홈 화면과 같이 다른 액티비티보다
	항상 우선하는 액티비티를 만들 때 유용하다.
	만약 홈 화면이 여러 개 있는 것이 아니라 하나만 만들어지는 것으로 하고 싶을 때, FLAG_ACTIVITY_SINGLE_TOP 플래그와 함께 사용하는것이
	유용하다.


※부가 데이터

- 데이터 전달은 static 사용을 하여 공유하는 방식보다 부가 데이터를 넣어 전달하는 방식을 권장한다.

- 인텐트 안에 번들 객체라는 것이 있는데, 해시 테이블과 유사하여 데이터를 넣고 빼는 것이 간단하다. 예를 들면, 문자열을 넣고 뺄 때 우리는
putExtra()와 getStringExtra()를 사용하면 된다.

	+ 기본적으로 자료형을 넣었다 뺄 수 있지만 바이트 배열이나 Serializable 객체도 넣었다 뺄 수 있다.

	+ 객체를 전달할 때는 바이트 배열로 변환 또는 Parcelable 인터페이스를 사용한다.